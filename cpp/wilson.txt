1. 防止编译器优化:
编译器可能会对代码进行优化，例如将变量缓存到寄存器中，或者省略一些不必要的读取操作。 volatile 告诉编译器不要对该变量进行这些优化，从而保证每次访问都是从内存中读取最新的值。 
2. 确保多线程环境下的可见性:
在多线程环境下，一个线程修改了 volatile 变量，其他线程可以立即看到这个修改，避免了数据不一致的问题。 

3. 支持硬件寄存器访问:
当程序需要直接访问硬件寄存器时，这些寄存器的值可能会被硬件改变，volatile 确保了每次访问都能读取到最新的值

需要注意的是：
volatile 并不保证原子性，对于复杂的并发操作，仍然需要使用互斥锁等机制来保证线程安全。
volatile 可能会导致一些性能损失，因为它阻止了编译器进行一些优化。 

========================

void* getAddress(int& value) { // 返回 void 指针 / Return void pointer
    return &value;
}

***************

void* ptr = getAddress(x);

============================
class Base {
public:
    virtual void print() { // 虚函数 / Virtual function
        std::cout << "Base::print() / 基类打印" << std::endl;
    }
    virtual ~Base() = default; // 虚析构函数 / Virtual destructor
};

class Derived : public Base {
public:
    void print() override { // 重写虚函数 / Override virtual function
        std::cout << "Derived::print() / 派生类打印" << std::endl;
    }
};

============

