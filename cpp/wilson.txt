1. 防止编译器优化:
编译器可能会对代码进行优化，例如将变量缓存到寄存器中，或者省略一些不必要的读取操作。 volatile 告诉编译器不要对该变量进行这些优化，从而保证每次访问都是从内存中读取最新的值。 
2. 确保多线程环境下的可见性:
在多线程环境下，一个线程修改了 volatile 变量，其他线程可以立即看到这个修改，避免了数据不一致的问题。 

3. 支持硬件寄存器访问:
当程序需要直接访问硬件寄存器时，这些寄存器的值可能会被硬件改变，volatile 确保了每次访问都能读取到最新的值

需要注意的是：
volatile 并不保证原子性，对于复杂的并发操作，仍然需要使用互斥锁等机制来保证线程安全。
volatile 可能会导致一些性能损失，因为它阻止了编译器进行一些优化。 

========================

void* getAddress(int& value) { // 返回 void 指针 / Return void pointer
    return &value;
}

***************

void* ptr = getAddress(x);

============================
class Base {
public:
    virtual void print() { // 虚函数 / Virtual function
        std::cout << "Base::print() / 基类打印" << std::endl;
    }
    virtual ~Base() = default; // 虚析构函数 / Virtual destructor
};

class Derived : public Base {
public:
    void print() override { // 重写虚函数 / Override virtual function
        std::cout << "Derived::print() / 派生类打印" << std::endl;
    }
};

============
using namespace std; // 使用整个命名空间 / Use entire namespace
using std::string; // 使用特定类型 / Use specific type

usage:
string str = "Hello"; // 不需要 std:: 前缀 / No need for std:: prefix

============

nsigned int x = 42; // 无符号整型 / Unsigned integer
    unsigned char c = 255; // 无符号字符 / Unsigned character
    unsigned long long big = 18446744073709551615ULL; // 无符号长长整型 / Unsigned long long

============

union Data {
    int i;
    float f;
    char str[20];
};

C++ 中的 union (共用體/联合体) 是一種特殊的類別，允許不同的資料類型共享同一塊記憶體空間。 這使得在需要節省記憶體的情況下，能更有效地利用記憶體資源。 當一個 union 中的成員被賦值時，其他成員的值會失效，因為它們共享相同的記憶體位置

優點：
節省記憶體: 這是 union 最主要的優點。
靈活的資料表示: 允許不同的資料類型共享同一塊記憶體，方便表示多種資料形態。
在某些情況下提高效能: 在某些特定的場景下，union 能夠減少記憶體操作的次數，從而提高程式的執行效率。

==========


